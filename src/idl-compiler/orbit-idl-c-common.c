#include "config.h"

#include "orbit-idl-c-backend.h"
#include <string.h>

static gboolean cc_output_tc_walker(IDL_tree_func_data *tfd, gpointer user_data);
static void cc_output_classids(IDL_tree tree, OIDL_C_Info *ci);

static void cc_typecode_prep_sequence(IDL_tree tree, OIDL_C_Info *ci);
static GSList *cc_build_interfaces (GSList *, IDL_tree tree);
static void cc_output_itypes (GSList *interfaces, OIDL_C_Info *ci);

typedef struct {
	IDL_tree tree;
	GSList  *methods; /* IDLN_OP_DCLs */
} Interface;

typedef struct {
	FILE     *of;
	IDL_tree  cur_node; /* Current Interface */
	char     *cur_id;
	guint     parents;
} CCInterfaceTraverseInfo;
 
static void
cc_output_typecodes(IDL_tree tree, OIDL_C_Info *ci)
{
  IDL_tree_walk2( tree, /*tfd*/0, IDL_WalkF_TypespecOnly,
		  /*pre*/ cc_output_tc_walker, /*post*/ cc_output_tc_walker, ci);
}

void
orbit_idl_output_c_common(OIDL_Output_Tree *tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  GSList *list;

  fprintf(ci->fh, "/*\n"
  		   " * This file was generated by orbit-idl - DO NOT EDIT!\n"
		   " */\n\n");
  fprintf(ci->fh, "#include <string.h>\n");
  fprintf(ci->fh, "#define ORBIT_IDL_C_COMMON\n");
  fprintf(ci->fh, "#define %s_COMMON\n", ci->c_base_name);
  fprintf(ci->fh, "#include \"%s.h\"\n\n", ci->base_name);
  fprintf(ci->fh, "#include <orbit/GIOP/giop.h>\n");
  fprintf(ci->fh, "static const CORBA_unsigned_long ORBit_zero_int = 0;\n");

  cc_output_typecodes(tree->tree, ci);

  cc_output_classids(tree->tree, ci);

  if ( rinfo->idata ) {
    fprintf(ci->fh, "\n/* Interface type data */\n\n");
    list = cc_build_interfaces (NULL, tree->tree);
    cc_output_itypes (list, ci);
  }
}

static gboolean
cc_output_tc_walker(IDL_tree_func_data *tfd, gpointer user_data)
{
    OIDL_C_Info *ci = user_data;
    IDL_tree tree = tfd->tree;

#if 0
  if ( tree->declspec & IDLF_DECLSPEC_PIDL ) {
        g_warning ("Pruned pidl");
	return FALSE;	/* prune */
  }
#endif

  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_CONST_DCL:
  case IDLN_ATTR_DCL:
  case IDLN_OP_DCL:
      return FALSE;	/* dont recurse into these */
  case IDLN_TYPE_SEQUENCE:
    cc_typecode_prep_sequence(tree, ci);
  case IDLN_INTERFACE: /* may need to be pre-order? */
  case IDLN_EXCEPT_DCL:
  case IDLN_TYPE_STRUCT:
  case IDLN_TYPE_UNION:
  case IDLN_TYPE_DCL:
  case IDLN_TYPE_ENUM:
  case IDLN_TYPE_FIXED:
    if ( tfd->step ) {
	/* do post-order */
        orbit_output_typecode(ci, tree);
    }
    break;
  default:
    break;
  }

  return TRUE;	/* continue walking */
}

/************************************************/

static void
cc_output_classids(IDL_tree tree, OIDL_C_Info *ci)
{
  if(!tree) return;

  if ( tree->declspec & IDLF_DECLSPEC_PIDL )
	return;

  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_MODULE:
    cc_output_classids(IDL_MODULE(tree).definition_list, ci);
    break;
  case IDLN_LIST:
    {
      IDL_tree sub;
      for(sub = tree; sub; sub = IDL_LIST(sub).next)
	cc_output_classids(IDL_LIST(sub).data, ci);
    }
    break;
  case IDLN_INTERFACE:
    {
    char *id;

    cc_output_classids(IDL_INTERFACE(tree).body, ci);

    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tree).ident), "_", 0);

    fprintf(ci->fh, "CORBA_unsigned_long %s__classid = 0;\n", id);
    g_free(id);
    }
    break;
  default:
    break;
  }
}

static void
cc_typecode_prep_sequence(IDL_tree tree, OIDL_C_Info *ci)
{
  char *ctmp, *ctmp2;
  gboolean separate_defs;
  IDL_tree tts, fake_seq;
  gboolean fake_if = FALSE;

  tts = orbit_cbe_get_typespec(IDL_TYPE_SEQUENCE(tree).simple_type_spec);

  ctmp = orbit_cbe_get_typespec_str(IDL_TYPE_SEQUENCE(tree).simple_type_spec);
  if(IDL_NODE_TYPE(tts) == IDLN_INTERFACE) {
    ctmp2 = g_strdup("CORBA_Object");
    fake_if = TRUE;
  } else
    ctmp2 = orbit_cbe_get_typespec_str(tts);
  separate_defs = strcmp(ctmp, ctmp2);
  g_free(ctmp);
  ctmp = g_strdup_printf("CORBA_sequence_%s", ctmp2);

  if(separate_defs)
    {
      if(fake_if)
	tts = IDL_type_object_new();
      fake_seq = IDL_type_sequence_new(tts, NULL);
      IDL_NODE_UP(fake_seq) = IDL_NODE_UP(tree);

      cc_output_typecodes(fake_seq, ci);

      if(!fake_if)
	IDL_TYPE_SEQUENCE(fake_seq).simple_type_spec = NULL;
      IDL_tree_free(fake_seq);
    }
}

/************************************************/

static void
cc_output_iargs (FILE *of, const char *method, IDL_tree tree)
{
	IDL_tree sub;
	int      arg_count = 0;

	/* Build a list of IArgs */
	for (sub = IDL_OP_DCL (tree).parameter_dcls; sub;
	     sub = IDL_LIST (sub).next) {
		IDL_tree parm;
		char    *tc;

		if (!arg_count)
			fprintf (of, "static ORBit_IArg %s__arginfo [] = {\n", method);

		parm = IDL_LIST(sub).data;

		fprintf (of, "\t{ ");

		/* TypeCode tc */
		tc = orbit_cbe_get_typecode_name (
			IDL_PARAM_DCL (parm).param_type_spec);
		if (!tc) {
			g_warning ("Can't get typecode");
			tc = g_strdup ("NULL /* no typecode */");
		}
		fprintf (of, "%s, ", tc);

		/* IArgFlag flags */
		switch (IDL_PARAM_DCL (parm).attr) {
		case IDL_PARAM_IN:
			fprintf (of, " ORBit_I_ARG_IN ");
			break;
		case IDL_PARAM_OUT:
			fprintf (of, " ORBit_I_ARG_OUT ");
			break;
		case IDL_PARAM_INOUT:
			fprintf (of, " ORBit_I_ARG_INOUT ");
			break;
		}

		if (orbit_cbe_type_is_fixed_length (
			IDL_PARAM_DCL (parm).param_type_spec))
			fprintf (of, "| ORBit_I_COMMON_FIXED_SIZE");

		else if (IDL_PARAM_DCL(parm).attr == IDL_PARAM_OUT) {

			IDL_tree ts = orbit_cbe_get_typespec (
				IDL_PARAM_DCL (parm).param_type_spec);

			switch(IDL_NODE_TYPE (ts)) {
			case IDLN_TYPE_STRUCT:
			case IDLN_TYPE_UNION:
			case IDLN_TYPE_ARRAY:
/*				fprintf (of, "| ORBIT_I_ARG_FIXED");*/
				break;
			default:
				break;
			};
		}

		fprintf (of, ", ");

		/* string name */
		fprintf (of, "\"%s\"", IDL_IDENT (IDL_PARAM_DCL (
			IDL_LIST (sub).data).simple_declarator).str);

		fprintf (of, " },\n");

		g_free (tc);
		arg_count++;
	}

	if (arg_count) {
		fprintf (of, "\t{ NULL, 0, NULL }\n");
		fprintf (of, "};\n");
	}
}

static void
cc_output_contexts (FILE *of, const char *method, IDL_tree tree)
{
	/* Build a list of contest names */
	if (IDL_OP_DCL (tree).context_expr) {
		IDL_tree curitem;

		fprintf (of, "/* Exceptions */\n");
		fprintf (of, "static CORBA_string %s__contextinfo [] = {\n",
			 method);

		for (curitem = IDL_OP_DCL (tree).context_expr; curitem;
		     curitem = IDL_LIST (curitem).next) {
			fprintf (of, "\"%s\"%c", 
				 IDL_STRING (IDL_LIST (curitem).data).value,
				 IDL_LIST (curitem).next ? ',' : ' ');
		}

		fprintf (of, "};\n");
	}
}

static void
cc_output_exceptinfo (FILE *of, const char *method, IDL_tree tree)
{
	/* Build a list of exception typecodes */
	if (IDL_OP_DCL (tree).raises_expr) {
		IDL_tree curitem;

		fprintf (of, "/* Exceptions */\n");
		fprintf (of, "static CORBA_TypeCode %s__exceptinfo [] = {\n",
			 method);
		
		for (curitem = IDL_OP_DCL (tree).raises_expr; curitem;
		     curitem = IDL_LIST(curitem).next) {
			char *type_id;
			IDL_tree curnode = IDL_LIST(curitem).data;
			
			type_id = orbit_cbe_get_typecode_name (curnode);
			fprintf (of, "\t%s,\n", type_id);
			g_free (type_id);
		}
		fprintf (of, "\tNULL\n};\n");
	}
}

static void
cc_output_method_bits (IDL_tree tree, const char *id, OIDL_C_Info *ci)
{
	OIDL_Op_Info *oi;
	FILE         *of = ci->fh;
	char         *fullname;

	fullname = g_strconcat (id, "_", IDL_IDENT (
		IDL_OP_DCL (tree).ident).str, NULL);

	oi = tree->data;
	g_assert (oi);

	cc_output_iargs (of, fullname, tree);

	cc_output_contexts (of, fullname, tree);

	cc_output_exceptinfo (of, fullname, tree);

	g_free (fullname);
}

static void
cc_output_method (FILE *of, IDL_tree tree, const char *id)
{
	int arg_count;
	int except_count;
	int context_count;
	const char *method;
	char       *fullname;

	fullname = g_strconcat (id, "_", IDL_IDENT (
		IDL_OP_DCL (tree).ident).str, NULL);

	arg_count = IDL_list_length (IDL_OP_DCL (tree).parameter_dcls);
	except_count = IDL_list_length (IDL_OP_DCL (tree).raises_expr);
	context_count = IDL_list_length (IDL_OP_DCL (tree).context_expr);
	
	fprintf (of, "\t{\n");

	/* IArgs arguments */
	if (arg_count)
		fprintf (of, "\t\t{ %d, %d, %s__arginfo, FALSE },\n",
			 arg_count, arg_count, fullname);
	else
		fprintf (of, "\t\t{ 0, 0, NULL, FALSE },\n");

	/* IContexts contexts */
	if (context_count)
		fprintf (of, "\t\t{ %d, %d, %s__contextinfo, FALSE },\n",
			 context_count, context_count, fullname);
	else
		fprintf (of, "\t\t{ 0, 0, NULL, FALSE },\n");
		
	/* ITypes exceptions */
	if (IDL_OP_DCL (tree).raises_expr)
		fprintf (of, "\t\t{ %d, %d, %s__exceptinfo, FALSE },\n",
			 except_count, except_count, fullname);
	else
		fprintf (of, "\t\t{ 0, 0, NULL, FALSE },\n");

	/* TypeCode ret */
	if (IDL_OP_DCL (tree).op_type_spec) {
		char *type_id;

		type_id = orbit_cbe_get_typespec_str (
			IDL_OP_DCL (tree).op_type_spec);
		fprintf (of, "\t\tTC_%s, ", type_id);
		g_free (type_id);
	} else
		fprintf (of, "CORBA_OBJECT_NIL, ");

	/* string name, long name_len */
	method = IDL_IDENT (IDL_OP_DCL (tree).ident).str;
	fprintf (of, "\"%s\", %d,\n", method, strlen (method) + 1);

	/* IMethodFlags flags */
	fprintf (of, "\t\t0");

	if (IDL_OP_DCL(tree).f_oneway)
		fprintf (of, " | ORBit_I_METHOD_1_WAY");

/* FIXME: re-scan for no_out */
/*	if (no_out)
	fprintf (of, " | ORBit_I_METHOD_NO_OUT");*/

	if (IDL_OP_DCL (tree).op_type_spec &&
	    orbit_cbe_type_is_fixed_length (
		    IDL_OP_DCL (tree).op_type_spec))
		fprintf (of, "| ORBit_I_COMMON_FIXED_SIZE");

	if (IDL_OP_DCL(tree).context_expr)
		fprintf (of, "| ORBit_I_METHOD_HAS_CONTEXT");

	fprintf (of, "\n},\n");

	g_free (fullname);
}

static void
cc_output_base_itypes(IDL_tree node, CCInterfaceTraverseInfo *iti)
{
	char      *id;

	if ( iti->cur_node == node ) return;

	id = IDL_ns_ident_to_qstring (IDL_IDENT_TO_NS (
			IDL_INTERFACE (node).ident), "_", 0);

	if ( iti->parents == 0 ) {
		fprintf (iti->of, 
			"static ORBit_IInterface %s__base_itypes[] = {\n", 
			iti->cur_id);
		}

	fprintf (iti->of, "{\"%s\",", id);
	fprintf (iti->of, "{%s_IMETHODS_LEN, %s_IMETHODS_LEN,\n", id, id );
	fprintf (iti->of, " %s__imethods, FALSE},\n", id);
	fprintf (iti->of, "{0, 0, NULL, FALSE}\n");
	fprintf (iti->of, "},\n");

	iti->parents++;

	g_free(id);
}

static void
cc_output_itypes (GSList *list, OIDL_C_Info *ci)
{
	GSList *l;
	FILE   *of = ci->fh;

	for (l = list; l; l = l->next) {
		CCInterfaceTraverseInfo iti;
		Interface *i = l->data;
		char      *id;
		GSList    *m;

		id = IDL_ns_ident_to_qstring (IDL_IDENT_TO_NS (
			IDL_INTERFACE (i->tree).ident), "_", 0);

		for (m = i->methods; m; m = m->next)
			cc_output_method_bits (m->data, id, ci);

		fprintf (of, "ORBit_IMethod %s__imethods [] = {\n", id);

		for (m = i->methods; m; m = m->next)
			cc_output_method (of, m->data, id);

		fprintf (of, "};\n");

		iti.of = of;
		iti.cur_node = i->tree;
		iti.cur_id = id;
		iti.parents = 0;
		IDL_tree_traverse_parents(i->tree, (GFunc)cc_output_base_itypes, &iti);

		if ( iti.parents != 0 )
			fprintf (of, "};\n", id);

		fprintf (of, "ORBit_IInterface %s__itype = {\n", id);
		fprintf (of, "\"%s\",", id);
		fprintf (of, "{%d, %d, %s__imethods, FALSE},\n",
			 g_slist_length (i->methods),
			 g_slist_length (i->methods), id);

		if ( iti.parents != 0 )
			fprintf (of, "{%d, %d, %s__base_itypes, FALSE}\n", 
						iti.parents, iti.parents, id);
		else
			fprintf (of, "{0, 0, NULL, FALSE}\n", id);

		fprintf (of, "};\n\n");

		g_free (id);
	}

	for (l = list; l; l = l->next) {
		g_slist_free (((Interface *)l->data)->methods);
		g_free (l->data);
		}

	g_slist_free (list);
}

static GSList *
cc_build_interfaces (GSList *list, IDL_tree tree)
{
	if (!tree)
		return list;

	switch (IDL_NODE_TYPE (tree)) {
	case IDLN_MODULE:
		list = cc_build_interfaces (
			list, IDL_MODULE (tree).definition_list);
		break;
	case IDLN_LIST: {
		IDL_tree sub;
		for (sub = tree; sub; sub = IDL_LIST (sub).next)
			list = cc_build_interfaces (
				list, IDL_LIST (sub).data);
		break;
	}
	case IDLN_ATTR_DCL: {
		OIDL_Attr_Info *ai = tree->data;
		IDL_tree curitem;
      
		for (curitem = IDL_ATTR_DCL (tree).simple_declarations;
		     curitem; curitem = IDL_LIST (curitem).next) {
			ai = IDL_LIST (curitem).data->data;
	
			list = cc_build_interfaces (list, ai->op1);
			if (ai->op2)
				list = cc_build_interfaces (list, ai->op2);
		}
		break;
	}
	case IDLN_INTERFACE: {
		Interface *i = g_new0 (Interface, 1);

		i->tree = tree;

		list = g_slist_append (list, i);

		list = cc_build_interfaces (list, IDL_INTERFACE(tree).body);

		break;
	}
	case IDLN_OP_DCL: {
		Interface *i;

		g_return_val_if_fail (list != NULL, NULL);

		i = ( g_slist_last(list) )->data;
		i->methods = g_slist_append (i->methods, tree);
		break;
	}
	case IDLN_EXCEPT_DCL:
		break;
	default:
		break;
	}

	return list;
}
