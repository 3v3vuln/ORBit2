#include "config.h"

#include "orbit-idl-c-backend.h"

static gboolean cc_output_tc_walker(IDL_tree_func_data *tfd, gpointer user_data);
static void cc_output_allocs(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);

static void cc_alloc_prep_sequence(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void cc_output_marshallers(OIDL_C_Info *ci);

void
orbit_idl_output_c_common(OIDL_Output_Tree *tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  fprintf(ci->fh, "/*\n"
  		   " * This file was generated by orbit-idl - DO NOT EDIT!\n"
		   " */\n\n");
  fprintf(ci->fh, "#include <string.h>\n");
  fprintf(ci->fh, "#define ORBIT_IDL_C_COMMON\n");
  fprintf(ci->fh, "#define %s_COMMON\n", ci->c_base_name);
  fprintf(ci->fh, "#include \"%s.h\"\n\n", ci->base_name);
  fprintf(ci->fh, "#include <orbit/GIOP/giop.h>\n");

  IDL_tree_walk2( tree->tree, /*tfd*/0, IDL_WalkF_TypespecOnly,
    /*pre*/ cc_output_tc_walker, /*post*/ cc_output_tc_walker, ci);

  cc_output_allocs(tree->tree, rinfo, ci);
  cc_output_marshallers(ci);
}

static gboolean
cc_output_tc_walker(IDL_tree_func_data *tfd, gpointer user_data) {
    OIDL_C_Info *ci = user_data;
    IDL_tree tree = tfd->tree;

  if ( tree->declspec & IDLF_DECLSPEC_PIDL )
	return FALSE;	/* prune */

  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_CONST_DCL:
  case IDLN_ATTR_DCL:
  case IDLN_OP_DCL:
      return FALSE;	/* dont recurse into these */
  case IDLN_INTERFACE: /* may need to be pre-order? */
  case IDLN_EXCEPT_DCL:
  case IDLN_TYPE_STRUCT:
  case IDLN_TYPE_UNION:
  case IDLN_TYPE_DCL:
  case IDLN_TYPE_ENUM:
  case IDLN_TYPE_FIXED:
  case IDLN_TYPE_SEQUENCE:
    if ( tfd->step ) {
	/* do post-order */
        orbit_output_typecode(ci, tree);
    }
    break;
  default:
    break;
  }
  return TRUE;	/* continue walking */
}


/************************************************/
static void cc_alloc_prep(IDL_tree tree, OIDL_C_Info *ci);
static void cc_output_alloc_interface(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void cc_output_alloc_struct(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void cc_output_alloc_union(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void cc_output_alloc_type_dcl(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);

static void
cc_output_allocs(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  if(!tree) return;

  if ( tree->declspec & IDLF_DECLSPEC_PIDL )
	return;

  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_MODULE:
    cc_output_allocs(IDL_MODULE(tree).definition_list, rinfo, ci);
    break;
  case IDLN_LIST:
    {
      IDL_tree sub;
      for(sub = tree; sub; sub = IDL_LIST(sub).next)
	cc_output_allocs(IDL_LIST(sub).data, rinfo, ci);
    }
    break;
  case IDLN_INTERFACE:
    cc_output_alloc_interface(tree, rinfo, ci);
    break;
  case IDLN_EXCEPT_DCL:
  case IDLN_TYPE_STRUCT:
    cc_output_alloc_struct(tree, rinfo, ci);
    break;
  case IDLN_TYPE_UNION:
    cc_output_alloc_union(tree, rinfo, ci);
    break;
  case IDLN_TYPE_DCL:
    cc_output_alloc_type_dcl(tree, rinfo, ci);
    break;
  case IDLN_TYPE_SEQUENCE:
    cc_alloc_prep_sequence(tree, rinfo, ci);
    break;
  case IDLN_CASE_STMT:
    cc_output_allocs(IDL_CASE_STMT(tree).element_spec, rinfo, ci);
    break;
  case IDLN_MEMBER:
    cc_output_allocs(IDL_MEMBER(tree).type_spec, rinfo, ci);
    break;
  default:
    break;
  }
}

static void
cc_output_alloc_interface(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  char *id;

  cc_output_allocs(IDL_INTERFACE(tree).body, rinfo, ci);

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tree).ident), "_", 0);

  fprintf(ci->fh, "CORBA_unsigned_long %s__classid = 0;\n", id);
  g_free(id);
}

static void
cc_output_alloc_struct(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  IDL_tree sub;
  char *tname;

  cc_alloc_prep(tree, ci);
  cc_output_allocs(IDL_TYPE_STRUCT(tree).member_list, rinfo, ci);

  tname = orbit_cbe_get_typespec_str(tree);
  /* XXX if tname is fixed_length (doesnt contain any pointers),
   * then we should #define the __freekids func */
  fprintf(ci->fh, "gpointer %s__freekids(gpointer mem, gpointer dat)\n", tname);
  fprintf(ci->fh, "{\n");
  fprintf(ci->fh, "%s *var = mem;\n", tname);
  for(sub = IDL_TYPE_STRUCT(tree).member_list; sub; sub = IDL_LIST(sub).next) {
    IDL_tree memb, sub2, ttmp;
    char *ctmp;

    memb = IDL_LIST(sub).data;

    if(orbit_cbe_type_is_fixed_length(IDL_MEMBER(memb).type_spec))
      continue;

    ttmp = orbit_cbe_get_typespec(IDL_MEMBER(memb).type_spec);
    ctmp = orbit_cbe_get_typespec_str(IDL_MEMBER(memb).type_spec);
    for(sub2 = IDL_MEMBER(memb).dcls; sub2; sub2 = IDL_LIST(sub2).next)
      fprintf(ci->fh, "%s__freekids(&(var->%s), NULL);\n", ctmp, IDL_IDENT(IDL_LIST(sub2).data).str);
    g_free(ctmp);
  }

  fprintf(ci->fh, "return (gpointer)(var + 1);\n");
  fprintf(ci->fh, "}\n\n");

  if(IDL_TYPE_STRUCT(tree).member_list) {
    fprintf(ci->fh, "%s *%s__alloc(void)\n", tname, tname);
    fprintf(ci->fh, "{\n");
    fprintf(ci->fh, "%s *retval;\n", tname);
    fprintf(ci->fh, "retval = ORBit_alloc(sizeof(%s), 1, %s__freekids);\n", tname, tname);

    for(sub = IDL_TYPE_STRUCT(tree).member_list; sub; sub = IDL_LIST(sub).next) {
      IDL_tree memb, sub2;

      memb = IDL_LIST(sub).data;

      if(orbit_cbe_type_is_fixed_length(IDL_MEMBER(memb).type_spec))
	continue;

      for(sub2 = IDL_MEMBER(memb).dcls; sub2; sub2 = IDL_LIST(sub2).next)
	fprintf(ci->fh, "memset(&(retval->%s), '\\0', sizeof(retval->%s));\n",
		IDL_IDENT(IDL_LIST(sub2).data).str,
		IDL_IDENT(IDL_LIST(sub2).data).str);
    }

    fprintf(ci->fh, "return retval;\n");
    fprintf(ci->fh, "}\n");
  }

  g_free(tname);
}

static void
cc_output_alloc_union(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  IDL_tree sub;
  char *tname;
  gboolean hit_default = FALSE;

  cc_alloc_prep(tree, ci);
  cc_output_allocs(IDL_TYPE_UNION(tree).switch_body, rinfo, ci);

  tname = orbit_cbe_get_typespec_str(tree);

  fprintf(ci->fh, "gpointer %s__freekids(gpointer mem, gpointer dat)\n", tname);
  fprintf(ci->fh, "{\n");

  fprintf(ci->fh, "%s *val = mem;\n", tname);

  fprintf(ci->fh, "switch(val->_d) {\n");
  for(sub = IDL_TYPE_UNION(tree).switch_body; sub; sub = IDL_LIST(sub).next) {
    IDL_tree cs, sub2, memb;

    cs = IDL_LIST(sub).data;

    if(IDL_CASE_STMT(cs).labels) {
      for(sub2 = IDL_CASE_STMT(cs).labels; sub2; sub2 = IDL_LIST(sub2).next) {
	if(IDL_LIST(sub2).data) {
	  fprintf(ci->fh, "case ");
	  orbit_cbe_write_const(ci->fh, IDL_LIST(sub2).data);
	  fprintf(ci->fh, ":\n");
	} else {
	  hit_default = TRUE;
	  fprintf(ci->fh, "default:\n");
	}
      }
    } else {
      hit_default = TRUE;
      fprintf(ci->fh, "default:\n");
    }

    memb = IDL_CASE_STMT(cs).element_spec;

    if(!orbit_cbe_type_is_fixed_length(IDL_MEMBER(memb).type_spec)) {
      char *ctmp;

      ctmp = orbit_cbe_get_typespec_str(IDL_MEMBER(memb).type_spec);
      fprintf(ci->fh, "%s__freekids(&(val->_u.%s), NULL);\n",
	      ctmp, IDL_IDENT(IDL_LIST(IDL_MEMBER(memb).dcls).data).str);
      g_free(ctmp);
    }

    fprintf(ci->fh, "break;\n");
  }
  if(!hit_default)
    fprintf(ci->fh, "default:\nbreak;\n");

  fprintf(ci->fh, "}\n");
  fprintf(ci->fh, "return (gpointer)(val + 1);\n");
  fprintf(ci->fh, "}\n");

  fprintf(ci->fh, "%s* %s__alloc(void)\n", tname, tname);
  fprintf(ci->fh, "{\n");
  fprintf(ci->fh, "%s *retval;\n", tname);
  fprintf(ci->fh, "retval = ORBit_alloc(sizeof(%s), 1, %s__freekids);\n",
	  tname, tname);
  if(!orbit_cbe_type_is_fixed_length(tree))
    fprintf(ci->fh, "memset(retval, '\\0', sizeof(%s));\n", tname);

  fprintf(ci->fh, "return retval;\n");
  fprintf(ci->fh, "}\n");
}


/**
   {node} is the IDLN_ARRAY (with corresponding new ident and size_list).
   {ts} is the element type of the array.
   Outputs the defintions of the __alloc() and __freekids() functions.
   Note that the __freekids() func is not used by the __alloc(); the
   __freekids() is only used when the array in embedded in a larger type.

   I think the whole mechanism may be slightly off, because it
   doesnt honour CORBA's recursive decomposition into slices.
**/
static void
cc_output_alloc_array(IDL_tree node, IDL_tree ts, 
  OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
    int i, n;
    char *ts_name, *tname;
    gboolean fixlen;
    IDL_tree curitem, ttmp;

    ts_name = orbit_cbe_get_typespec_str(ts);
    fixlen = orbit_cbe_type_is_fixed_length(ts);

    tname = orbit_cbe_get_typespec_str(node);
    n = IDL_list_length(IDL_TYPE_ARRAY(node).size_list);

    fprintf(ci->fh, "gpointer %s__freekids(gpointer mem, gpointer dat)\n", tname);
    fprintf(ci->fh, "{\n");
    if(fixlen) {
	fprintf(ci->fh, "gpointer retval = ((guchar *)mem) + sizeof(%s);\n", tname);
    } else {
	fprintf(ci->fh, "gpointer retval = mem, slice = mem;\n");
	for(i = 0; i < n; i++) {
	  fprintf(ci->fh, "int n%d;\n", i);
	}

	for(i = 0, ttmp = IDL_TYPE_ARRAY(node).size_list; i < n; i++, ttmp = IDL_LIST(ttmp).next) {
	  fprintf(ci->fh, "for(n%d = 0; n%d < %" IDL_LL "d; n%d++) {\n",
		  i, i, IDL_INTEGER(IDL_LIST(ttmp).data).value, i);
	}
      
	fprintf(ci->fh, "retval = %s__freekids(&((%s_slice *)slice)", ts_name, tname);
	for(i = 0; i < n; i++)
	  fprintf(ci->fh, "[n%d]", i);
	fprintf(ci->fh, ", NULL);\n");
      
	for(i = 0; i < n; i++) {
	  fprintf(ci->fh, "}\n");
	}
    }
    fprintf(ci->fh, "return retval;\n");
    fprintf(ci->fh, "}\n\n");
    /* end-of __freekids */

    fprintf(ci->fh, "%s_slice* %s__alloc(void)\n", tname, tname);
    fprintf(ci->fh, "{\n");
    fprintf(ci->fh, "%s_slice *retval;\n", tname);
    fprintf(ci->fh, "  retval = ORBit_alloc(sizeof(%s), 1", ts_name);
    curitem = IDL_TYPE_ARRAY(node).size_list;
    for(; curitem; curitem = IDL_LIST(curitem).next)
      fprintf(ci->fh, "*%" IDL_LL "d", IDL_INTEGER(IDL_LIST(curitem).data).value);
    if(fixlen) {
      fprintf(ci->fh, ", NULL);\n");
    } else {
      fprintf(ci->fh, ", %s__freekids);\n", ts_name);
      /* WATCHOUT: the __freekids above is the underlying ts, not the new type! */
      fprintf(ci->fh, "memset(retval, '\\0', sizeof(%s));\n", tname);
    }
    fprintf(ci->fh, "return retval;\n");
    fprintf(ci->fh, "}\n");

    g_free(tname);
    g_free(ts_name);
}


static void
cc_output_alloc_type_dcl(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  IDL_tree sub, ts, tts;
  gboolean fixlen;

  cc_alloc_prep(tree, ci);
  ts = IDL_TYPE_DCL(tree).type_spec;
  tts = orbit_cbe_get_typespec(ts);

  if (IDL_NODE_TYPE(tts) == IDLN_INTERFACE
      || IDL_NODE_TYPE(tts) == IDLN_TYPE_OBJECT)
    return;

  cc_output_allocs(IDL_TYPE_DCL(tree).type_spec, rinfo, ci);

  fixlen = orbit_cbe_type_is_fixed_length(ts);

  for(sub = IDL_TYPE_DCL(tree).dcls; sub; sub = IDL_LIST(sub).next) {
    IDL_tree node;

    node = IDL_LIST(sub).data;

    switch(IDL_NODE_TYPE(node)) {
    case IDLN_IDENT:
      if(fixlen)
	continue;
      if(IDL_NODE_TYPE(tts) == IDLN_TYPE_STRING
	 || IDL_NODE_TYPE(tts) == IDLN_TYPE_WIDE_STRING)
	 continue;	/* why? - because strings don't need alloc functions */
      break;
    case IDLN_TYPE_ARRAY:
      cc_output_alloc_array(node, ts, rinfo, ci);
      break;
    default:
      g_assert_not_reached();
      break;
    }
  }
}


static void
cc_alloc_prep(IDL_tree tree, OIDL_C_Info *ci)
{
#if 0
  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_TYPE_SEQUENCE:
    cc_alloc_prep_sequence(tree, ci);
    break;
  case IDLN_EXCEPT_DCL:
  case IDLN_TYPE_STRUCT:
    {
      IDL_tree sub;

      for(sub = IDL_TYPE_STRUCT(tree).member_list; sub; sub = IDL_LIST(sub).next) {
	cc_alloc_prep(IDL_MEMBER(IDL_LIST(sub).data).type_spec, ci);
      }
    }
    break;
  case IDLN_TYPE_DCL:
    cc_alloc_prep(IDL_TYPE_DCL(tree).type_spec, ci);
    break;
  case IDLN_TYPE_UNION:
    {
      IDL_tree sub;

      for(sub = IDL_TYPE_UNION(tree).switch_body; sub; sub = IDL_LIST(sub).next) {
	IDL_tree member;

	member = IDL_CASE_STMT(IDL_LIST(sub).data).element_spec;

	cc_alloc_prep(IDL_MEMBER(member).type_spec, ci);
      }
    }
    break;
  case IDLN_TYPE_ARRAY:
    cc_alloc_prep(IDL_NODE_UP(tree), ci);
    break;
  case IDLN_IDENT:
  case IDLN_LIST:
    cc_alloc_prep(IDL_NODE_UP(tree), ci);
    break;
  default:
    break;
  }
#endif
}

/**
    Note that the __freekids is always a #define in the header.
**/
static void
cc_alloc_prep_sequence(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  char *ctmp, *ctmp2, *ctmp3;
  gboolean elements_are_fixed;
  IDL_tree tts;

  tts = orbit_cbe_get_typespec(IDL_TYPE_SEQUENCE(tree).simple_type_spec);
  cc_output_allocs(IDL_TYPE_SEQUENCE(tree).simple_type_spec, rinfo, ci);

#if 0
  ctmp = orbit_cbe_get_typespec_str(tree);
  ctmp2 = orbit_cbe_get_typespec_str(IDL_TYPE_SEQUENCE(tree).simple_type_spec);
#endif
  ctmp3 = orbit_cbe_get_typespec_str(tts);
  ctmp = g_strdup_printf("CORBA_sequence_%s", ctmp3);
  ctmp2 = g_strdup(ctmp3);

  fprintf(ci->fh, "#if ");
  orbit_cbe_id_cond_hack(ci->fh, "ORBIT_IMPL", ctmp, ci->c_base_name);
  fprintf(ci->fh, " && !defined(ORBIT_DEF_%s)", ctmp);
  fprintf(ci->fh, " && !defined(%s__alloc)\n", ctmp);
  fprintf(ci->fh, "#define ORBIT_DEF_%s 1\n\n", ctmp);
  fprintf(ci->fh, "%s *%s__alloc(void)\n", ctmp, ctmp);
  fprintf(ci->fh, "{\n");
  fprintf(ci->fh, "  %s *retval;\n", ctmp);
  fprintf(ci->fh, "  retval = ORBit_alloc(sizeof(%s), 1, %s__freekids);\n", 
  			ctmp, ctmp);

  fprintf(ci->fh, "  retval->_maximum = ");
  if(IDL_TYPE_SEQUENCE(tree).positive_int_const) {
    orbit_cbe_write_const(ci->fh, IDL_TYPE_SEQUENCE(tree).positive_int_const);
  } else
    fprintf(ci->fh, "0");
  fprintf(ci->fh, ";\n");

  fprintf(ci->fh, "  retval->_length = 0;\n");
  fprintf(ci->fh, "  retval->_buffer = NULL;\n");
  fprintf(ci->fh, "  retval->_release = CORBA_FALSE;\n");

  fprintf(ci->fh, "  return retval;\n}\n");

  elements_are_fixed = orbit_cbe_type_is_fixed_length(IDL_TYPE_SEQUENCE(tree).simple_type_spec);
  fprintf(ci->fh, "%s* %s_allocbuf(CORBA_unsigned_long len)\n", ctmp2, ctmp);
  fprintf(ci->fh, "{\n%s* retval = ", ctmp2);
  if(elements_are_fixed) {
      fprintf(ci->fh, "ORBit_alloc_simple(sizeof(%s)*len);\n", ctmp2);
  } else {
      fprintf(ci->fh, "ORBit_alloc(sizeof(%s), len, %s__freekids);\n", 
        ctmp2, ctmp2);
      fprintf(ci->fh, "memset(retval, '\\0', sizeof(%s)*len);\n", ctmp2);
  }
  fprintf(ci->fh, "return retval;\n");
  fprintf(ci->fh, "}\n");

  fprintf(ci->fh, "#endif\n\n");

  g_free(ctmp);
  g_free(ctmp2);
}

static void
build_marshal_funcs(gpointer key, gpointer value, gpointer data)
{
  OIDL_C_Info *ci = data;
  IDL_tree tree = key;
  OIDL_Type_Marshal_Info *tmi = value;
  OIDL_Marshal_Node *node;
  OIDL_Populate_Info pi;
  char *ctmp;

  pi.ctxt = ci->ctxt;

  if(IDL_NODE_TYPE(tree) == IDLN_TYPE_SEQUENCE)
    {
      char *ctmp2;
      ctmp2 = orbit_cbe_get_typespec_str(orbit_cbe_get_typespec(IDL_TYPE_SEQUENCE(tree).simple_type_spec));
      ctmp = g_strdup_printf("CORBA_sequence_%s", ctmp2);
      g_free(ctmp2);
    }
  else
    ctmp = orbit_cbe_get_typespec_str(tree);

  fprintf(ci->fh, "#if ");
  orbit_cbe_id_cond_hack(ci->fh, "MARSHAL_IMPL", ctmp, ci->c_base_name);
  fprintf(ci->fh, " && !defined(ORBIT_MARSHAL_%s)\n", ctmp);
  fprintf(ci->fh, "#define ORBIT_MARSHAL_%s 1\n\n", ctmp);

  if(tmi->avail_mtype & MARSHAL_FUNC)
    {
      pi.flags = PI_BUILD_FUNC;
      pi.where = MW_Null|MW_Heap;
      node = marshal_populate(tree, NULL, &pi);
      orbit_idl_do_node_passes(node, FALSE);

      node->name = "_ORBIT_val";
      node->nptrs = oidl_param_numptrs(tree, DATA_IN);

      fprintf(ci->fh, "void %s_marshal(GIOPSendBuffer *_ORBIT_send_buffer, ", ctmp);
      orbit_cbe_write_param_typespec_raw(ci->fh, tree, DATA_IN);
      fprintf(ci->fh, " _ORBIT_val, CORBA_Environment *ev)\n{\n");
      orbit_cbe_alloc_tmpvars(node, ci);
      c_marshalling_generate(node, ci, FALSE);
      fprintf(ci->fh, "}\n");
    }

  if(tmi->avail_dmtype & MARSHAL_FUNC)
    {
      pi.flags = PI_BUILD_FUNC;
      pi.where = MW_Null;
      node = marshal_populate(tree, NULL, &pi);
      node->name = "_ORBIT_val";
      node->nptrs = oidl_param_numptrs(tree, DATA_IN);

      orbit_idl_do_node_passes(node, TRUE);

      fprintf(ci->fh, "gboolean\n%s_demarshal(GIOPRecvBuffer *_ORBIT_recv_buffer, ", ctmp);
      orbit_cbe_write_param_typespec_raw(ci->fh, tree, DATA_INOUT);
      fprintf(ci->fh, " _ORBIT_val, CORBA_boolean do_dup, CORBA_Environment *ev)\n{\n");
      fprintf(ci->fh, "register guchar *_ORBIT_curptr;\n");
      fprintf(ci->fh, "register guchar *_ORBIT_buf_end = _ORBIT_recv_buffer->end;\n");
      orbit_cbe_alloc_tmpvars(node, ci);
      c_demarshalling_generate(node, ci, FALSE, TRUE);
      fprintf(ci->fh, "return FALSE;");
      fprintf(ci->fh, "_ORBIT_demarshal_error:\nreturn TRUE;\n");
      fprintf(ci->fh, "}\n");
    }
  fprintf(ci->fh, "#endif\n\n");
  g_free(ctmp);
}

static void
cc_output_marshallers(OIDL_C_Info *ci)
{
  g_hash_table_foreach(ci->ctxt->type_marshal_info, build_marshal_funcs, ci);
}
