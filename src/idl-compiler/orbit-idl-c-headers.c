#include "config.h"
#include "orbit-idl-c-backend.h"

/* TODO:
   Interfaces.
 */

#include <string.h>

/* #define DO_CPP */

/* ch = C header */
static void ch_output_types(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_output_poa(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_output_protos(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);

void
orbit_idl_output_c_headers(OIDL_Output_Tree *tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  fprintf(ci->fh, "/*\n"
	  " * This file was generated by orbit-idl - DO NOT EDIT!\n"
	  " */\n\n");
  fprintf(ci->fh, "#include <glib.h>\n");
  fprintf(ci->fh, "#define ORBIT_IDL_SERIAL %d\n", ORBIT_SERIAL);
  fprintf(ci->fh, "#include <orb/orbit.h>\n\n");

#ifdef DO_CPP
  fprintf(ci->fh, "#ifdef __cplusplus\n");
  fprintf(ci->fh, "extern \"C\" {\n");
  fprintf(ci->fh, "#endif /* __cplusplus */\n\n");
#endif

  /* Do all the typedefs, etc. */
  ch_output_types(tree->tree, rinfo, ci);
  /* Do all the POA structures, etc. */
  ch_output_poa(tree->tree, rinfo, ci);
  /* Do all the stub prototypes */
  ch_output_protos(tree->tree, rinfo, ci);

#if DO_CPP
  fprintf(ci->fh, "#ifdef __cplusplus\n");
  fprintf(ci->fh, "}\n");
  fprintf(ci->fh, "#endif /* __cplusplus */\n\n");
#endif

  fprintf(ci->fh, "#undef ORBIT_IDL_SERIAL\n");
}

static void
ch_output_var(IDL_tree val, IDL_tree name, OIDL_C_Info *ci)
{
  orbit_cbe_write_typespec(ci->fh, val);

  fprintf(ci->fh, " ");
  switch(IDL_NODE_TYPE(name)) {
  case IDLN_IDENT:
    fprintf(ci->fh, "%s", IDL_IDENT(name).str);
    break;
  case IDLN_TYPE_ARRAY:
    {
      IDL_tree curitem;

      fprintf(ci->fh, "%s", IDL_IDENT(IDL_TYPE_ARRAY(name).ident).str);
      for(curitem = IDL_TYPE_ARRAY(name).size_list; curitem; curitem = IDL_LIST(curitem).next) {
	fprintf(ci->fh, "[%qd]", IDL_INTEGER(IDL_LIST(curitem).data).value);
      }
    }
    break;
  default:
    g_error("Weird varname - %s", IDL_tree_type_names[IDL_NODE_TYPE(name)]);
    break;
  }
  fprintf(ci->fh, ";\n");
}

static void ch_output_type_struct(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_output_type_enum(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_output_type_dcl(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_output_type_union(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci);
static void ch_prep(IDL_tree tree, OIDL_C_Info *ci);
static void ch_type_alloc_and_tc(IDL_tree tree, OIDL_C_Info *ci, gboolean do_alloc);

static void
ch_output_types(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_MODULE:
    ch_output_types(IDL_MODULE(tree).definition_list, rinfo, ci);
    break;
  case IDLN_LIST:
    {
      IDL_tree sub;

      for(sub = tree; sub; sub = IDL_LIST(sub).next) {
	ch_output_types(IDL_LIST(sub).data, rinfo, ci);
      }
    }
    break;
  case IDLN_FORWARD_DCL:
    {
      char *fullname;

      fullname = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_FORWARD_DCL(tree).ident), "_", 0);

      fprintf(ci->fh, "#ifndef DEF_%s\n#define DEF_%s 1\n", fullname, fullname);
      fprintf(ci->fh, "typedef CORBA_Object %s;\n", fullname);
      fprintf(ci->fh, "#endif\n");
      g_free(fullname);
    }
    break;
  case IDLN_INTERFACE:
    {
      char *fullname;

      fullname = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tree).ident), "_", 0);

      fprintf(ci->fh, "#ifndef DEF_%s\n#define DEF_%s 1\n", fullname, fullname);
      fprintf(ci->fh, "typedef CORBA_Object %s;\n", fullname);
      fprintf(ci->fh, "#endif\n");
      g_free(fullname);

      ch_output_types(IDL_INTERFACE(tree).body, rinfo, ci);
    }
    break;
  case IDLN_TYPE_STRUCT:
    ch_output_type_struct(tree, rinfo, ci);
    break;
  case IDLN_TYPE_ENUM:
    ch_output_type_enum(tree, rinfo, ci);
    break;
  case IDLN_TYPE_DCL:
    ch_output_type_dcl(tree, rinfo, ci);
    break;
  case IDLN_TYPE_UNION:
    ch_output_type_union(tree, rinfo, ci);
    break;
  default:
    break;
  }
}

static void
ch_output_type_enum(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  IDL_tree curitem;
  char *id, *enumid;

  /* CORBA spec says to do
	   typedef unsigned int enum_name;
     and then #defines for each enumerator.
     This works just as well and seems cleaner.
  */

  enumid = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_TYPE_ENUM(tree).ident), "_", 0);
  fprintf(ci->fh, "typedef enum {\n");

  for(curitem = IDL_TYPE_ENUM(tree).enumerator_list;
      curitem;
      curitem = IDL_LIST(curitem).next) {
    id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_LIST(curitem).data), "_", 0);

    fprintf(ci->fh, "  %s%s\n",
	    id,
	    IDL_LIST(curitem).next?",":"");

    g_free(id);
  }

  fprintf(ci->fh, "} %s;\n", enumid);

  ch_type_alloc_and_tc(tree, ci, FALSE);

  g_free(enumid);
}


static void
ch_output_type_struct(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  char *id;
  IDL_tree cur, curmem;

  /* First, scan for any "weird sequences" */
  for(cur = IDL_TYPE_STRUCT(tree).member_list; cur; cur = IDL_LIST(cur).next) {
    IDL_tree ts;

    ts = IDL_MEMBER(IDL_LIST(cur).data).type_spec;

    ch_prep(ts, ci);
  }

  fprintf(ci->fh, "typedef struct {\n");

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_TYPE_STRUCT(tree).ident), "_", 0);
  for(cur = IDL_TYPE_STRUCT(tree).member_list; cur; cur = IDL_LIST(cur).next) {
    for(curmem = IDL_MEMBER(IDL_LIST(cur).data).dcls; curmem; curmem = IDL_LIST(curmem).next) {
      ch_output_var(IDL_MEMBER(IDL_LIST(cur).data).type_spec, IDL_LIST(curmem).data, ci);
    }
  }
  fprintf(ci->fh, "} %s;\n\n", id);

  ch_type_alloc_and_tc(tree, ci, TRUE);

  g_free(id);
}

static void
ch_output_type_dcl(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  char *ctmp;
  IDL_tree curitem, ent, sub;

  ch_prep(IDL_TYPE_DCL(tree).type_spec, ci);

  fprintf(ci->fh, "typedef ");
  orbit_cbe_write_typespec(ci->fh, IDL_TYPE_DCL(tree).type_spec);

  for(curitem = IDL_TYPE_DCL(tree).dcls; curitem; curitem = IDL_LIST(curitem).next) {
    ent = IDL_LIST(curitem).data;

    switch(IDL_NODE_TYPE(ent)) {
    case IDLN_IDENT:
      {
	ctmp = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(ent), "_", 0);
	fprintf(ci->fh, " %s;\n", ctmp);
	g_free(ctmp);
      }
      break;
    case IDLN_TYPE_ARRAY:
      {
	ctmp = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_TYPE_ARRAY(ent).ident), "_", 0);
	fprintf(ci->fh, " %s", ctmp);
	for(sub = IDL_TYPE_ARRAY(ent).size_list; sub; sub = IDL_LIST(sub).next)
	  fprintf(ci->fh, "[%qd]", IDL_INTEGER(IDL_LIST(sub).data).value);
	fprintf(ci->fh, ";\n");
	fprintf(ci->fh, "typedef ");
	orbit_cbe_write_typespec(ci->fh, IDL_TYPE_DCL(tree).type_spec);
	fprintf(ci->fh, " %s_slice", ctmp);
	for(sub = IDL_LIST(IDL_TYPE_ARRAY(ent).size_list).next; sub; sub = IDL_LIST(sub).next)
	  fprintf(ci->fh, "[%qd]", IDL_INTEGER(IDL_LIST(sub).data).value);
	fprintf(ci->fh, ";\n");
	g_free(ctmp);
	ch_type_alloc_and_tc(ent, ci, TRUE);
      }
      break;
    default:
      g_error("Huh?");
      break;
    }
  }
}

static void
ch_output_type_union(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  char *id;
  IDL_tree curitem;

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_TYPE_UNION(tree).ident), "_", 0);
  fprintf(ci->fh, "typedef struct {\n");
  orbit_cbe_write_typespec(ci->fh, IDL_TYPE_UNION(tree).switch_type_spec);
  fprintf(ci->fh, " _d;\nunion {\n");

  for(curitem = IDL_TYPE_UNION(tree).switch_body; curitem; curitem = IDL_LIST(curitem).next) {
    IDL_tree member;

    member = IDL_CASE_STMT(IDL_LIST(curitem).data).element_spec;
    ch_output_var(IDL_MEMBER(member).type_spec,
		  IDL_LIST(IDL_MEMBER(member).dcls).data,
		  ci);
  }

  fprintf(ci->fh, "} _u;\n} %s;\n", id);

  ch_type_alloc_and_tc(tree, ci, TRUE);

  g_free(id);
}

static void ch_prep_sequence(IDL_tree tree, OIDL_C_Info *ci);
static void ch_prep_fixed(IDL_tree tree, OIDL_C_Info *ci);

static
void ch_prep(IDL_tree tree, OIDL_C_Info *ci)
{
  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_TYPE_SEQUENCE:
    ch_prep_sequence(tree, ci);
    break;
  case IDLN_TYPE_FIXED:
    ch_prep_fixed(tree, ci);
    break;
  default:
    break;
  }
}

static void
ch_prep_fixed(IDL_tree tree, OIDL_C_Info *ci)
{
  char *ctmp;

  ctmp = orbit_cbe_get_typename(tree);
  fprintf(ci->fh,
	  "typedef struct { CORBA_unsigned_short _digits; CORBA_short _scale; CORBA_char _value[%d]; } %s;\n",
	  (int) (IDL_INTEGER(IDL_TYPE_FIXED(tree).positive_int_const).value + 2)/2,
	  ctmp);
  g_free(ctmp);

  ch_type_alloc_and_tc(tree, ci, TRUE);
}

static void
ch_prep_sequence(IDL_tree tree, OIDL_C_Info *ci)
{
  char *ctmp;

  if(IDL_NODE_TYPE(IDL_TYPE_SEQUENCE(tree).simple_type_spec) == IDLN_TYPE_SEQUENCE)
    ch_prep_sequence(IDL_TYPE_SEQUENCE(tree).simple_type_spec, ci);

  fprintf(ci->fh, "typedef struct { CORBA_unsigned_long _maximum, _length; ");
  orbit_cbe_write_typespec(ci->fh, IDL_TYPE_SEQUENCE(tree).simple_type_spec);
  fprintf(ci->fh, "* _buffer; CORBA_boolean _release; } ");
  orbit_cbe_write_typespec(ci->fh, tree);
  fprintf(ci->fh, ";\n");

  ch_type_alloc_and_tc(tree, ci, TRUE);

  ctmp = orbit_cbe_get_typename(IDL_TYPE_SEQUENCE(tree).simple_type_spec);
  fprintf(ci->fh, "extern %s *CORBA_sequence_%s_allocbuf(CORBA_unsigned_long len);\n",
	  ctmp, (!strncmp(ctmp, "CORBA_", strlen("CORBA_")))?(ctmp+strlen("CORBA_")):ctmp);
  g_free(ctmp);
}

static void
ch_type_alloc_and_tc(IDL_tree tree, OIDL_C_Info *ci, gboolean do_alloc)
{
  char *ctmp;

  ctmp = orbit_cbe_get_typename(tree);
  fprintf(ci->fh, "extern const struct CORBA_TypeCode_struct TC_%s_struct;\n", ctmp);
  fprintf(ci->fh, "#define TC_%s (&TC_%s_struct)\n", ctmp, ctmp);

  if(do_alloc) {
    fprintf(ci->fh, "extern %s%s* %s__alloc(void);\n", ctmp,
	    (IDL_NODE_TYPE(tree) == IDLN_TYPE_ARRAY)?"_slice":"",
	    ctmp);
    fprintf(ci->fh,
	    "extern gpointer %s__free(gpointer mem, gpointer dat, CORBA_boolean free_strings); /* ORBit internal use */\n",
	    ctmp);
  }

  g_free(ctmp);
}

/************************/
static void
ch_output_poa(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_MODULE:
    ch_output_poa(IDL_MODULE(tree).definition_list, rinfo, ci);
    break;
  case IDLN_LIST:
    {
      IDL_tree sub;

      for(sub = tree; sub; sub = IDL_LIST(sub).next) {
	ch_output_poa(IDL_LIST(sub).data, rinfo, ci);
      }
    }
    break;
  case IDLN_INTERFACE:
    {
      IDL_tree sub;
      char *id;

      id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(tree).ident), "_", 0);

      /* First, do epv for this interface, then vepv, then servant */
      fprintf(ci->fh, "typedef struct {\n");

      for(sub = IDL_INTERFACE(tree).body; sub; sub = IDL_LIST(sub).next) {
	IDL_tree cur;

	cur = IDL_LIST(sub).data;

	if(IDL_NODE_TYPE(cur) != IDLN_OP_DCL) continue;

	orbit_cbe_op_write_proto(ci->fh, cur, "", TRUE);
      }

      fprintf(ci->fh, "} POA_%s__epv", id);

      g_free(id);
    }
    break;
  default:
    break;
  }
}

/************************/
static void
ch_output_protos(IDL_tree tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
}
