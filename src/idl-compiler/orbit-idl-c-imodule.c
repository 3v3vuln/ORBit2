#include "config.h"

#include "orbit-idl-c-backend.h"
#include <string.h>

static GSList *cc_small_build_interfaces (GSList *list, IDL_tree tree);
static void cc_small_output_imodule (GSList *interfaces, OIDL_C_Info *ci);

typedef struct {
	IDL_tree tree;
	guint    method_count;
} Interface;

typedef struct {
	IDL_tree cur_node; /* Current Interface */
	guint    parents;
} CCSmallInterfaceTraverseInfo;
 
void
orbit_idl_output_c_imodule(OIDL_Output_Tree *tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  GSList *list;

  fprintf(ci->fh, "/*\n"
  		   " * This file was generated by orbit-idl - DO NOT EDIT!\n"
		   " */\n\n");
  fprintf(ci->fh, "#include <string.h>\n");
  fprintf(ci->fh, "#define ORBIT_IDL_C_IMODULE\n");
  fprintf(ci->fh, "#define %s_IMODLE\n\n", ci->c_base_name);
  fprintf(ci->fh, "#include <orbit/orb-core/orbit-interface.h>\n");
  fprintf(ci->fh, "#include \"%s-common.c\"\n\n", ci->base_name);

  list = cc_small_build_interfaces (NULL, tree->tree);
  cc_small_output_imodule (list, ci);
}

static void
cc_small_output_base_itypes(IDL_tree node, CCSmallInterfaceTraverseInfo *iti)
{
	if (iti->cur_node == node)
		return;

	iti->parents++;
}

static void
cc_small_output_imodule (GSList *list, OIDL_C_Info *ci)
{
	GSList *l;
	FILE   *of = ci->fh;
	long    iinterface_count = 0;

	fprintf (of, "static ORBit_IInterface %s__iinterfaces[] = {\n",
		 ci->base_name);

	for (l = list; l; l = l->next) {
		CCSmallInterfaceTraverseInfo iti;
		Interface *i = l->data;
		char      *id;

		iinterface_count++;

		id = IDL_ns_ident_to_qstring (IDL_IDENT_TO_NS (
			IDL_INTERFACE (i->tree).ident), "_", 0);

		iti.cur_node = i->tree;
		iti.parents = 0;
		IDL_tree_traverse_parents(i->tree, (GFunc)cc_small_output_base_itypes, &iti);

		fprintf (of, "   {TC_%s,", id);
		fprintf (of, "      {%d, %d, %s__imethods, FALSE},\n",
			 i->method_count, i->method_count, id);

		fprintf (of, "      {%d, %d, %s__base_itypes, FALSE}}", 
			 iti.parents + 1, iti.parents + 1, id);

		fprintf (of, (l->next) ? ",\n" : "\n");

		g_free (id);
	}

	fprintf (of, "};\n\n");

	fprintf (of, "ORBit_IModule orbit_imodule_data = {\n");
	fprintf (of, "   %ld,\n", ORBIT_CONFIG_SERIAL);
	fprintf (of, "   {%ld, %ld, %s__iinterfaces, FALSE}\n",
		 iinterface_count, iinterface_count, ci->base_name);
	fprintf (of, "};\n\n");

	for (l = list; l; l = l->next) {
		g_free (l->data);
	}

	g_slist_free (list);
}


static GSList *
cc_small_build_interfaces (GSList *list, IDL_tree tree)
{
	if (!tree)
		return list;

	switch (IDL_NODE_TYPE (tree)) {
	case IDLN_MODULE:
		list = cc_small_build_interfaces (
			list, IDL_MODULE (tree).definition_list);
		break;
	case IDLN_LIST: {
		IDL_tree sub;
		for (sub = tree; sub; sub = IDL_LIST (sub).next)
			list = cc_small_build_interfaces (
				list, IDL_LIST (sub).data);
		break;
	}
	case IDLN_INTERFACE: {
		Interface *i = g_new0 (Interface, 1);

		i->tree = tree;

		list = g_slist_append (list, i);

		list = cc_small_build_interfaces (
			list, IDL_INTERFACE(tree).body);

		break;
	}
	case IDLN_OP_DCL: {
		Interface *i;

		g_return_val_if_fail (list != NULL, NULL);

		i = ( g_slist_last(list) )->data;
		i->method_count++;
		break;
	}
	default:
		break;
	}

	return list;
}
