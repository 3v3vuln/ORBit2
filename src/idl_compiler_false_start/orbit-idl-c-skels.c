#include "config.h"

#include "orbit-idl-c-backend.h"

static void ck_output_skels(IDL_tree tree, OIDL_C_Info *ci);

void
orbit_idl_output_c_skeletons(OIDL_Output_Tree *tree, OIDL_Run_Info *rinfo, OIDL_C_Info *ci)
{
  fprintf(ci->fh, "/*\n"
  		   " * This file was generated by orbit-idl - DO NOT EDIT!\n"
		   " */\n\n");
  fprintf(ci->fh, "#include <string.h>\n");
  fprintf(ci->fh, "#include \"%s.h\"\n\n", ci->base_name);

  ck_output_skels(tree->tree, ci);
}

static void ck_output_skel(IDL_tree tree, OIDL_C_Info *ci);
static void ck_output_except(IDL_tree tree, OIDL_C_Info *ci);

static void
ck_output_skels(IDL_tree tree, OIDL_C_Info *ci)
{
  if(!tree) return;

  switch(IDL_NODE_TYPE(tree)) {
  case IDLN_MODULE:
    ck_output_skels(IDL_MODULE(tree).definition_list, ci);
    break;
  case IDLN_LIST:
    {
      IDL_tree sub;
      for(sub = tree; sub; sub = IDL_LIST(sub).next) {
	ck_output_skels(IDL_LIST(sub).data, ci);
      }
    }
    break;
  case IDLN_ATTR_DCL:
    {
      OIDL_Attr_Info *ai = tree->data;

      ck_output_skels(ai->op1, ci);
      if(ai->op2)
	ck_output_skels(ai->op2, ci);
    }
    break;
  case IDLN_INTERFACE:
    ck_output_skels(IDL_INTERFACE(tree).body, ci);
    break;
  case IDLN_OP_DCL:
    ck_output_skel(tree, ci);
    break;
  case IDLN_EXCEPT_DCL:
    ck_output_except(tree, ci);
    break;
  default:
    break;
  }
}

static void
cbe_print_var_dcl(FILE *of, IDL_tree tree, gboolean for_skels)
{
  /* variant of print_param_dcl */
  IDL_ParamRole r = DATA_IN;
  IDL_tree ts;
  int i, n;

  if(IDL_NODE_TYPE(tree) != IDLN_PARAM_DCL) {
    orbit_cbe_write_typespec(of, tree);
    ts = orbit_cbe_get_typespec(tree);

    if(IDL_NODE_TYPE(ts) == IDLN_TYPE_ARRAY)
      fprintf(of, "_slice*");

    n = oidl_param_numptrs(tree, DATA_RETURN);

    for(i = 0; i < n; i++)
      fprintf(of, "*");

    fprintf(of, " _ORBIT_retval");
  } else {

    ts = orbit_cbe_get_typespec(IDL_PARAM_DCL(tree).param_type_spec);

    orbit_cbe_write_typespec(of,
			     IDL_PARAM_DCL(tree).param_type_spec);


    r = oidl_attr_to_paramrole(IDL_PARAM_DCL(tree).attr);

    if((IDL_NODE_TYPE(ts) == IDLN_TYPE_ARRAY)
       && (r == DATA_OUT)
       && !orbit_cbe_type_is_fixed_length(ts)) 
      fprintf(of, "_slice*");

    n = oidl_param_numptrs(IDL_PARAM_DCL(tree).param_type_spec, r);
    for(i = 0; i < (n - for_skels); i++) {
      fprintf(of, "*");
    }
    fprintf(of, " %s", IDL_IDENT(IDL_PARAM_DCL(tree).simple_declarator).str);

    if((n - for_skels) <= 0)
      switch(IDL_NODE_TYPE(ts)) {
      case IDLN_TYPE_ANY:
	fprintf(of, "= {NULL, NULL, CORBA_FALSE}");
	break;
      case IDLN_TYPE_SEQUENCE:
	fprintf(of, "= {0, 0, NULL, CORBA_FALSE}");
	break;
      default:
        break;
      }
  }
}

static void ck_skel_alloc_tmpvars(OIDL_Marshal_Node *node, OIDL_C_Info *ci);

static void
ck_output_skel(IDL_tree tree, OIDL_C_Info *ci)
{
  char *opname, *ifname;
  IDL_tree intf, curitem;
  OIDL_Op_Info *oi;

  intf = IDL_get_parent_node(tree, IDLN_INTERFACE, NULL);

  opname = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_OP_DCL(tree).ident), "_", 0);
  ifname = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_INTERFACE(intf).ident), "_", 0);

  fprintf(ci->fh, "void _ORBIT_skel_%s(POA_%s * _ORBIT_servant, GIOPRecvBuffer *_ORBIT_recv_buffer, CORBA_Environment *ev, ",
	  opname, ifname);
  orbit_cbe_op_write_proto(ci->fh, tree, "_impl_", TRUE);
  fprintf(ci->fh, ")\n");
  fprintf(ci->fh, "{\n");

  if(IDL_OP_DCL(tree).op_type_spec) {
    cbe_print_var_dcl(ci->fh, IDL_OP_DCL(tree).op_type_spec, TRUE);
    fprintf(ci->fh, ";\n");
  }
  for(curitem = IDL_OP_DCL(tree).parameter_dcls; curitem; curitem = IDL_LIST(curitem).next) {
    cbe_print_var_dcl(ci->fh, IDL_LIST(curitem).data, TRUE);
    fprintf(ci->fh, ";\n");
  }

  fprintf(ci->fh, "{ /* demarshalling */\n");
  fprintf(ci->fh, "guchar *_ORBIT_curptr;\n");

  oi = tree->data;
  c_demarshalling_generate(oi->in_skels, ci, TRUE);

  fprintf(ci->fh, "}\n");

  if(IDL_OP_DCL(tree).op_type_spec)
    fprintf(ci->fh, "_ORBIT_retval = ");
  fprintf(ci->fh, "_impl_%s(_ORBIT_servant, ", IDL_IDENT(IDL_OP_DCL(tree).ident).str);
  fprintf(ci->fh, "ev);\n");

  if(!IDL_OP_DCL(tree).f_oneway) {
    fprintf(ci->fh, "{ /* marshalling */\n");
    

    if(IDL_OP_DCL(tree).raises_expr) {
      IDL_tree curitem;
      
      fprintf(ci->fh, "static const ORBit_exception_marshal_info _ORBIT_user_exceptions[] = { ");
      for(curitem = IDL_OP_DCL(tree).raises_expr; curitem;
	  curitem = IDL_LIST(curitem).next) {
	char *id;
	IDL_tree curnode = IDL_LIST(curitem).data;
	
	id = orbit_cbe_get_typename(curnode);
	fprintf(ci->fh, "{(const CORBA_TypeCode)&TC_%s_struct, (gpointer)_ORBIT_%s_marshal},",
		id, id);
	g_free(id);
      }
      fprintf(ci->fh, "{CORBA_OBJECT_NIL, NULL}};\n");
    }

    c_marshalling_generate(oi->out_skels, ci);

    fprintf(ci->fh, "}\n");
  }

  fprintf(ci->fh, "}\n");

  g_free(opname);
  g_free(ifname);
}

static void
ck_output_except(IDL_tree tree, OIDL_C_Info *ci)
{
  char *id;
  OIDL_Except_Info *ei;

  ei = tree->data;
  g_assert(ei);

  id = IDL_ns_ident_to_qstring(IDL_IDENT_TO_NS(IDL_EXCEPT_DCL(tree).ident), "_", 0);

  fprintf(ci->fh, "void\n_ORBIT_%s_marshal(GIOPSendBuffer *_ORBIT_recv_buffer, CORBA_Environment *ev)\n", id);
  fprintf(ci->fh, "{\n");
  if(IDL_EXCEPT_DCL(tree).members) {
    fprintf(ci->fh, "guchar *_ORBIT_curptr;\n");
    fprintf(ci->fh, "%s *_ORBIT_exdata = ev->_params;\n", id);
    c_marshalling_generate(ei->demarshal, ci);
  }

  fprintf(ci->fh, "}\n");

  g_free(id);
}

static void
ck_skel_alloc_tmpvar(OIDL_Marshal_Node *node, OIDL_C_Info *ci)
{
  if(!(node->flags & MN_NEED_TMPVAR))
    return;

  if(node->flags & MN_NOMARSHAL)
    fprintf(ci->fh, "register "); /* Help the compiler out */

  if(node->tree) {
    int i;
    orbit_cbe_write_typespec(ci->fh, node->tree);
    for(i = 0; i < node->nptrs; i++)
      fprintf(ci->fh, "*");
    fprintf(ci->fh, " %s;\n", node->name);
  } else if(node->type == MARSHAL_DATUM) {
    const char * ctmp;
    static const char * const size_names[] = {NULL, "CORBA_unsigned_char", "CORBA_unsigned_short", NULL, "CORBA_unsigned_long",
					      NULL, NULL, NULL, "CORBA_unsigned_long_long"};
    ctmp = size_names[node->u.datum_info.datum_size];
    g_assert(ctmp);
    fprintf(ci->fh, "%s %s;\n", ctmp, node->name);
  } else
    g_error("Don't know how to handle tmpvar %s", node->name);
}

static void
ck_skel_alloc_tmpvars(OIDL_Marshal_Node *node, OIDL_C_Info *ci)
{
  orbit_idl_node_foreach(node, (GFunc)ck_skel_alloc_tmpvar, ci);
}
